<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Examples.Ltl.Simple</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">sine-nomine-0.0.0</span><ul class="links" id="page-menu"><li><a href="src/Examples.Ltl.Simple.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Examples.Ltl.Simple</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Example domain and implementation</a></li><li><a href="#g:2">Using the effect system</a></li><li><a href="#g:3">Defining a type of single-step modifications</a></li><li><a href="#g:4">Interpreting modified <code>AST</code>s</a></li><li><a href="#g:5">A few example traces</a><ul><li><a href="#g:6"><code>somewhere</code> and <code>everywhere</code></a></li><li><a href="#g:7">Custom <code>Ltl</code> formulas</a></li></ul></li><li><a href="#g:8">&quot;Finding&quot; a bug</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A simple, but complete, tutorial for  how to use <a href="Logic-Ltl.html">Logic.Ltl</a>. This does
 not cover</p><ul><li>using higher-order effects in the LTL setting, and</li><li>combining several different effects in one test scenario.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="#t:MonadKeyValue">MonadKeyValue</a> k v m <span class="keyword">where</span><ul class="subs"><li><a href="#v:storeValue">storeValue</a> :: k -&gt; v -&gt; m ()</li><li><a href="#v:getValue">getValue</a> :: k -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> v)</li><li><a href="#v:deleteValue">deleteValue</a> :: k -&gt; m ()</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:KeyValueT">KeyValueT</a> k v = <a href="https://hackage.haskell.org/package/-/docs/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> (<a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v)</li><li class="src short"><a href="#v:runKeyValueT">runKeyValueT</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> k v m a -&gt; m (a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v)</li><li class="src short"><span class="keyword">data</span> <a href="#t:KeyValueEffect">KeyValueEffect</a> k v :: <a href="Effect.html#t:Effect" title="Effect">Effect</a> <span class="keyword">where</span><ul class="subs"><li><a href="#v:StoreValue">StoreValue</a> :: k -&gt; v -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v m ()</li><li><a href="#v:GetValue">GetValue</a> :: k -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> v)</li><li><a href="#v:DeleteValue">DeleteValue</a> :: k -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v m ()</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:SingleStepMod">SingleStepMod</a> = <a href="#v:ConcatIfReplace">ConcatIfReplace</a></li><li class="src short"><a href="#v:interpretAndRun">interpretAndRun</a> :: (<a href="https://hackage.haskell.org/package/-/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> v, <a href="https://hackage.haskell.org/package/-/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v -&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> '[<a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v] a -&gt; [(a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v)]</li><li class="src short"><a href="#v:exampleSomewhere1">exampleSomewhere1</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)]</li><li class="src short"><a href="#v:exampleSomewhere2">exampleSomewhere2</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)]</li><li class="src short"><a href="#v:exampleEverywhere1">exampleEverywhere1</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)]</li><li class="src short"><a href="#v:exampleEverywhere2">exampleEverywhere2</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)]</li><li class="src short"><a href="#v:exampleEverywhere3">exampleEverywhere3</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)]</li><li class="src short"><a href="#v:exampleCustom1">exampleCustom1</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)]</li><li class="src short"><a href="#v:exampleBug">exampleBug</a> :: <a href="https://hackage.haskell.org/package/-/docs/Test-Tasty-Providers.html#t:TestTree" title="Test.Tasty.Providers">TestTree</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Example domain and implementation</h1></a><div class="doc"><p>It's easiest to use this library if you have a type class of monads that
 captures the behaviour you want to test. For the sake of this tutorial, let's
 take a key-value-store.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a id="t:MonadKeyValue" class="def">MonadKeyValue</a> k v m <span class="keyword">where</span> <a href="src/Examples.Ltl.Simple.html#MonadKeyValue" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:storeValue" class="def">storeValue</a> :: k -&gt; v -&gt; m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a id="v:getValue" class="def">getValue</a> :: k -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> v) <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a id="v:deleteValue" class="def">deleteValue</a> :: k -&gt; m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MonadKeyValue">Instances</h4><details id="i:MonadKeyValue" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadKeyValue:MonadKeyValue:1"></span> ((), <a href="Effect.html#t:EffectInject" title="Effect">EffectInject</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v) ops) =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> k v (<a href="Effect.html#t:AST" title="Effect">AST</a> ops)</span> <a href="src/Examples.Ltl.Simple.html#line-85" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadKeyValue:MonadKeyValue:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: k -&gt; v -&gt; <a href="Effect.html#t:AST" title="Effect">AST</a> ops () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: k -&gt; <a href="Effect.html#t:AST" title="Effect">AST</a> ops (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> v) <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: k -&gt; <a href="Effect.html#t:AST" title="Effect">AST</a> ops () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadKeyValue:MonadKeyValue:2"></span> (<a href="https://hackage.haskell.org/package/-/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> k v (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> k v m)</span> <a href="src/Examples.Ltl.Simple.html#line-53" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadKeyValue:MonadKeyValue:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: k -&gt; v -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> k v m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: k -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> k v m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> v) <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: k -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> k v m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadKeyValue:MonadKeyValue:3"></span> (<a href="https://hackage.haskell.org/package/-/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> k v (<a href="Examples-Ltl-HigherOrder.html#t:MiniLangT" title="Examples.Ltl.HigherOrder">MiniLangT</a> e k v m)</span> <a href="src/Examples.Ltl.HigherOrder.html#line-42" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadKeyValue:MonadKeyValue:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-HigherOrder.html">Examples.Ltl.HigherOrder</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: k -&gt; v -&gt; <a href="Examples-Ltl-HigherOrder.html#t:MiniLangT" title="Examples.Ltl.HigherOrder">MiniLangT</a> e k v m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: k -&gt; <a href="Examples-Ltl-HigherOrder.html#t:MiniLangT" title="Examples.Ltl.HigherOrder">MiniLangT</a> e k v m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> v) <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: k -&gt; <a href="Examples-Ltl-HigherOrder.html#t:MiniLangT" title="Examples.Ltl.HigherOrder">MiniLangT</a> e k v m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>What we'll test is an implementation of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>. We'll implement it
 very simply, but note that the implementation of <code><a href="Examples-Ltl-Simple.html#v:deleteValue" title="Examples.Ltl.Simple">deleteValue</a></code> is wrong: we
 never delete anything from the store. We'll &quot;find&quot; this mistake later on.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:KeyValueT" class="def">KeyValueT</a> k v = <a href="https://hackage.haskell.org/package/-/docs/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> (<a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v) <a href="src/Examples.Ltl.Simple.html#KeyValueT" class="link">Source</a> <a href="#t:KeyValueT" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:runKeyValueT" class="def">runKeyValueT</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> k v m a -&gt; m (a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v) <a href="src/Examples.Ltl.Simple.html#runKeyValueT" class="link">Source</a> <a href="#v:runKeyValueT" class="selflink">#</a></p></div><a href="#g:2" id="g:2"><h1>Using the effect system</h1></a><div class="doc"><p>This library based on a custom effect system. The central type is <code><code><a href="Effect.html#t:AST" title="Effect">AST</a></code> ops
 a</code>. It describes abstract syntax trees of monadic computations which use
 operations from the list <code>ops</code> of <em>effect types</em>, and return an <code>a</code>. Such
 <code><a href="Effect.html#t:AST" title="Effect">AST</a></code>s will be <em>interpreted</em> in various ways to obtain interesting test
 cases.</p><p>So, we'll have to write an effect type for the key-value store. The
 constructors of that effect type will correspond to the methods of the
 class <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>. We can think of them as abstract representations that
 stand for the methods.</p><p>The kind of effect types is</p><pre>Effect = (Type -&gt; Type) -&gt; Type -&gt; Type</pre><p>The <code>(Type -&gt; Type)</code> parameter doesn't interest us here; it is the &quot;nesting&quot;
 monad used for higher order effects. The second parameter is the return type
 of the method.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:KeyValueEffect" class="def">KeyValueEffect</a> k v :: <a href="Effect.html#t:Effect" title="Effect">Effect</a> <span class="keyword">where</span> <a href="src/Examples.Ltl.Simple.html#KeyValueEffect" class="link">Source</a> <a href="#t:KeyValueEffect" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:StoreValue" class="def">StoreValue</a> :: k -&gt; v -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v m ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:GetValue" class="def">GetValue</a> :: k -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:DeleteValue" class="def">DeleteValue</a> :: k -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:KeyValueEffect">Instances</h4><details id="i:KeyValueEffect" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueEffect:InterpretLtl:1"></span> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> v, <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> k v m) =&gt; <a href="Logic-Ltl.html#t:InterpretLtl" title="Logic.Ltl">InterpretLtl</a> <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> m (<a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v)</span> <a href="src/Examples.Ltl.Simple.html#line-187" class="link">Source</a> <a href="#t:KeyValueEffect" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueEffect:InterpretLtl:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretLtl">interpretLtl</a> :: <span class="keyword">forall</span> (dummy :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v dummy a -&gt; <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Logic.Ltl.html#interpretLtl" class="link">Source</a> <a href="#v:interpretLtl" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueEffect:InterpretEffect:2"></span> ((), <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> k v m) =&gt; <a href="Effect.html#t:InterpretEffect" title="Effect">InterpretEffect</a> m (<a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v)</span> <a href="src/Examples.Ltl.Simple.html#line-85" class="link">Source</a> <a href="#t:KeyValueEffect" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueEffect:InterpretEffect:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffect">interpretEffect</a> :: <span class="keyword">forall</span> (ops :: [<a href="Effect.html#t:Effect" title="Effect">Effect</a>]) a. (<span class="keyword">forall</span> b. <a href="Effect.html#t:AST" title="Effect">AST</a> ops b -&gt; m b) -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v (<a href="Effect.html#t:AST" title="Effect">AST</a> ops) a -&gt; m a <a href="src/Effect.html#interpretEffect" class="link">Source</a> <a href="#v:interpretEffect" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>If the constructor names of <code><a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a></code> are the method names of
 <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code> (starting with an upper case letter) and the types match,
 the Template Haskell macro <code><a href="Effect-TH.html#v:makeEffect" title="Effect.TH">makeEffect</a></code> can be used to generate two instance
 definitions:</p><p>The &quot;reification&quot; instance</p><pre>instance (EffectInject (KeyValueEffect k v) ops) =&gt; MonadKeyValue k v (AST ops) where</pre><p>says that, if <code>KeyValueEffect k v</code> is an element of the list of effects
 <code>ops</code>, then an <code><a href="Effect.html#t:AST" title="Effect">AST</a></code> that uses the effect list <code>ops</code> is an instance of
 <code>MonadKeyValue k v</code>. This will allow us to write <code><a href="Effect.html#t:AST" title="Effect">AST</a></code>s using the familiar
 syntax of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>.</p><p>The &quot;interpretation&quot; instance</p><pre>instance (MonadKeyValue k v m) =&gt; InterpretEffect m (KeyValueEffect k v) where</pre><p>says that the <code>KeyValueEffect k v</code> can be interpreted into any
 <code>MonadKeyValue k v</code>.</p><p>If you have to add extra constraints to the instances, you can use the more
 flexible macros <code><a href="Effect-TH.html#v:makeReification" title="Effect.TH">makeReification</a></code> and <code><a href="Effect-TH.html#v:makeInterpretation" title="Effect.TH">makeInterpretation</a></code>.</p><p>If all effects in an <code><a href="Effect.html#t:AST" title="Effect">AST</a></code> have a suitable <code><a href="Effect.html#t:InterpretEffect" title="Effect">InterpretEffect</a></code> instance,
 you'll be able to interpret the complete <code><a href="Effect.html#t:AST" title="Effect">AST</a></code> with functions like
 <code><a href="Effect.html#v:interpretAST" title="Effect">interpretAST</a></code>. So, what we've accomplished up to now is just as in any
 other effect system: we have a single monad <code><a href="Effect.html#t:AST" title="Effect">AST</a></code> that is parametrised on
 the effect(s) you want to use, and an &quot;interpetation&quot; function that turns
 the &quot;staged&quot; computations in <code><a href="Effect.html#t:AST" title="Effect">AST</a></code>s into actual computations in your domain
 of interest.</p><p>At the very least, <code><a href="Effect-TH.html#v:makeEffect" title="Effect.TH">makeEffect</a></code> and friends will need the following language
 extensions:</p><pre>{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell #-}</pre><p>For effect types with parameters (like <code>k</code> and <code>v</code> in <code><a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a></code>,
 you'll also need</p><pre>{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}</pre><p>There are scenarios where you might also need <code>UndecidableInstances</code> but
 we'll not discuss these here.</p></div><a href="#g:3" id="g:3"><h1>Defining a type of single-step modifications</h1></a><div class="doc"><p>The module <a href="Logic-Ltl.html">Logic.Ltl</a> implements one way to turn the effect system into a
 testing tool. Its idea is to change the interpretaion of an <code><a href="Effect.html#t:AST" title="Effect">AST</a></code> by
 applying single-step modifications the actions it contains. A formula in an
 LTL-like language determines when to apply the single-step modifications.</p><p>So, we first need a type of single-step modifications. These have no
 intrinsic meaning, but will only be explained by the <code><a href="Logic-Ltl.html#t:InterpretLtl" title="Logic.Ltl">InterpretLtl</a></code>
 instance.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SingleStepMod" class="def">SingleStepMod</a> <a href="src/Examples.Ltl.Simple.html#SingleStepMod" class="link">Source</a> <a href="#t:SingleStepMod" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:ConcatIfReplace" class="def">ConcatIfReplace</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:SingleStepMod">Instances</h4><details id="i:SingleStepMod" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SingleStepMod:Semigroup:1"></span> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a></span> <a href="src/Examples.Ltl.Simple.html#line-160" class="link">Source</a> <a href="#t:SingleStepMod" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SingleStepMod:Semigroup:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SingleStepMod:InterpretLtl:2"></span> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> v, <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> k v m) =&gt; <a href="Logic-Ltl.html#t:InterpretLtl" title="Logic.Ltl">InterpretLtl</a> <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> m (<a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v)</span> <a href="src/Examples.Ltl.Simple.html#line-187" class="link">Source</a> <a href="#t:SingleStepMod" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SingleStepMod:InterpretLtl:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretLtl">interpretLtl</a> :: <span class="keyword">forall</span> (dummy :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v dummy a -&gt; <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Logic.Ltl.html#interpretLtl" class="link">Source</a> <a href="#v:interpretLtl" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>The evaluation of <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formulas sometimes makes it necessary to try
 applying two <code><a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a></code>s on the same step. The <code><a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a></code> instance
 describes how they should combine. (In our example, it's very simple,
 because there is only one <code><a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a></code>, namely <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code>.)</p></div><div class="doc"><p>The <code><a href="Logic-Ltl.html#t:InterpretLtl" title="Logic.Ltl">InterpretLtl</a></code> instance is the heart of this while operation, since it
 describes how we to apply <code><a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a></code>s to <code><a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a></code>s. We
 have to write a function</p><pre>interpretLtl :: KeyValueEffect k v dummy a -&gt; SingleStepMod -&gt; m (Maybe a)</pre><p>which describes for each <code><a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a></code> if and how it is modified by each
 modification. If the modification applies, it should return <code><a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>,
 otherwise <code><a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>. The <code>dummy</code> type argument to <code><a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a></code> isn't
 interesting to us here, it'll only be relevant for higer-order effects.</p><p>In our example, we make it so that the meaning of <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code> is: &quot;If
 you see a <code><code><a href="Examples-Ltl-Simple.html#v:StoreValue" title="Examples.Ltl.Simple">StoreValue</a></code> key value</code> and there's already some <code>oldValue</code> for
 that <code>key</code> in the store, don't just store <code>value</code>, store <code>oldValue &lt;&gt;
 newValue</code>.&quot;</p><p>Note that this meaning of <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code> depends on the state of the
 store. Herein lies a strength of this framework: what we're doing is really
 more general than generating a list of <code><a href="Effect.html#t:AST" title="Effect">AST</a></code>s and evaluating them in a
 second step. The parameters and applicability of the modification we apply
 at the <code>n</code>-th step may depend on information we know only after having run
 (and modified) the first <code>n-1</code> steps.</p></div><a href="#g:4" id="g:4"><h1>Interpreting modified <code>AST</code>s</h1></a><div class="doc"><p>The module <a href="Logic-Ltl.html">Logic.Ltl</a> provides the wrapper type <code><code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> mod ops</code>, which
 is an <code><a href="Effect.html#t:AST" title="Effect">AST</a></code> in which you'll have access to the function</p><pre>modifyLtl :: Ltl mod -&gt; LtlAST mod ops a -&gt; LtlAST mod ops a</pre><p>This is what makes it possible to deploy composite <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> modifications: wrap
 the part of the computation you want to modify in <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code> with the <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 formula of your choice.</p><p>The module also provides</p><pre>interpretLtlAST :: forall mod m ops a. (Semigroup mod, MonadPlus m, InterpretEffectsLtl mod m ops) =&gt; LtlAST mod ops a -&gt; m a</pre><p>which interprets the <code><code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> mod ops</code> into any suitable monad <code>m</code>. Here,
 &quot;suitable&quot; means:</p><ul><li>All of the effects in <code>ops</code> have an 'InterpretLtl mod m' instance (this is
   the <code><a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a></code> constraint).</li><li><code>m</code> is a <code><a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a></code>. This is necessary because there might be several
   ways to satisfy an <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula. The whole point of using <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> do describe
   modifications of a single trace is to try <em>all</em> of the possible ways to
   apply the formula.</li></ul><p>Using <code><a href="Logic-Ltl.html#v:interpretLtlAST" title="Logic.Ltl">interpretLtlAST</a></code>, we can write a convenience function that will
 interpret an <code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> of <code><a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a></code>s and return the final return value
 and state of the store:</p></div><div class="top"><p class="src"><a id="v:interpretAndRun" class="def">interpretAndRun</a> :: (<a href="https://hackage.haskell.org/package/-/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> v, <a href="https://hackage.haskell.org/package/-/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v -&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> <a href="Examples-Ltl-Simple.html#t:SingleStepMod" title="Examples.Ltl.Simple">SingleStepMod</a> '[<a href="Examples-Ltl-Simple.html#t:KeyValueEffect" title="Examples.Ltl.Simple">KeyValueEffect</a> k v] a -&gt; [(a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k v)] <a href="src/Examples.Ltl.Simple.html#interpretAndRun" class="link">Source</a> <a href="#v:interpretAndRun" class="selflink">#</a></p></div><a href="#g:5" id="g:5"><h1>A few example traces</h1></a><a href="#g:6" id="g:6"><h2><code>somewhere</code> and <code>everywhere</code></h2></a><div class="doc"><p>By for the most commonly used <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula is <code><a href="Logic-Ltl.html#v:somewhere" title="Logic.Ltl">somewhere</a></code>. The <code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code></p><pre>somewhere x (act1 &gt;&gt; act2 &gt;&gt; act3)</pre><p>describes the three traces you get by applying <code>x</code> to <code>act1</code>, <code>act2</code>, and
 <code>act3</code>, while leaving the other actions unmodified. Only traces where <code>x</code>
 was <em>successfully</em> will be returned by <code>interpretLTLAST</code>, though. This means
 that our first example will return an empty list, since <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code>
 never applies (as we never <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code> for a key that's already present).</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleSomewhere1
</code></strong>[]
</pre></div><div class="top"><p class="src"><a id="v:exampleSomewhere1" class="def">exampleSomewhere1</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)] <a href="src/Examples.Ltl.Simple.html#exampleSomewhere1" class="link">Source</a> <a href="#v:exampleSomewhere1" class="selflink">#</a></p></div><div class="doc"><p>In the next example, we'll expect two results, because there are two
 positions in which <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code> applies, namely the second and third
 <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code>. Let's explain the two results:</p><ul><li>If we apply <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code> to the second <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code>, the store will
   hold <code>&quot;Hello&quot;</code> for key <code>1</code>, so we'll store <code>&quot;Hello my&quot;</code>. However, this is
   invisible in the result, because the third <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code> will overwrite this
   with &quot;friend&quot;.</li><li>If we apply <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code> to the third <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code>, the store will hold
   <code>&quot;my&quot;</code> at key <code>1</code>, so we'll store <code>&quot;my friend&quot;</code>. Since there are no more
   <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code> operations after that, that's also what we see in the result.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleSomewhere2
</code></strong>[((),fromList [(1,&quot;friend&quot;)]),((),fromList [(1,&quot;my friend&quot;)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleSomewhere2" class="def">exampleSomewhere2</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)] <a href="src/Examples.Ltl.Simple.html#exampleSomewhere2" class="link">Source</a> <a href="#v:exampleSomewhere2" class="selflink">#</a></p></div><div class="doc"><p>Another very commonly used <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula is <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code>. It applies the
 given single-step modification to every action in the <code><a href="Effect.html#t:AST" title="Effect">AST</a></code>.</p><p>This means that our next example will again return the empty list, since
 <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code> isn't applicable on the first <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhere1
</code></strong>[]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhere1" class="def">exampleEverywhere1</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhere1" class="link">Source</a> <a href="#v:exampleEverywhere1" class="selflink">#</a></p></div><div class="doc"><p>Note that, unlike <code><a href="Logic-Ltl.html#v:somewhere" title="Logic.Ltl">somewhere</a></code>, <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code> doesn't imply that any
 modification is applied. Applying <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code> to an empty trace is
 successful, and returns one result:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhere2
</code></strong>[((),fromList [])]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhere2" class="def">exampleEverywhere2</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhere2" class="link">Source</a> <a href="#v:exampleEverywhere2" class="selflink">#</a></p></div><div class="doc"><p>We can make the modification applicable, and return the expected <code>&quot;Hello my
 friend&quot;</code>  at key <code>1</code>, if we only apply <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code> after the first action:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhere3
</code></strong>[((),fromList [(1,&quot;Hello my friend&quot;)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhere3" class="def">exampleEverywhere3</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhere3" class="link">Source</a> <a href="#v:exampleEverywhere3" class="selflink">#</a></p></div><a href="#g:7" id="g:7"><h2>Custom <code>Ltl</code> formulas</h2></a><div class="doc"><p>Another way to make the <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code> example work is by using a custom <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 formula: instead of applying <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code> on every action, let's only
 start applying at the second action using <code><code><a href="Logic-Ltl.html#v:LtlNext" title="Logic.Ltl">LtlNext</a></code> . <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleCustom1
</code></strong>[((),fromList [(1,&quot;Hello my friend&quot;)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleCustom1" class="def">exampleCustom1</a> :: [((), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>)] <a href="src/Examples.Ltl.Simple.html#exampleCustom1" class="link">Source</a> <a href="#v:exampleCustom1" class="selflink">#</a></p></div><div class="doc"><p>There are many possibilities for custom formulas. Please refer to the
 documentation
 of <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>.</p></div><a href="#g:8" id="g:8"><h1>&quot;Finding&quot; a bug</h1></a><div class="doc"><p>Remember the mistake we introduced in the implementation of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>
 for <code><a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a></code>? We &quot;accidentally&quot; implemented <code><a href="Examples-Ltl-Simple.html#v:deleteValue" title="Examples.Ltl.Simple">deleteValue</a></code> as a no-op.
 This means that, by using <code><a href="Examples-Ltl-Simple.html#v:deleteValue" title="Examples.Ltl.Simple">deleteValue</a></code> before re-storing a value, we
 <em>should</em> make <code><a href="Examples-Ltl-Simple.html#v:ConcatIfReplace" title="Examples.Ltl.Simple">ConcatIfReplace</a></code> inapplicable. The following simple test
 finds this bug.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Tasty.defaultMain exampleBug
</code></strong>deleteValue before re-store: FAIL
  ./Examples/Ltl/Simple.hs:353:
  expected: []
   but got: [((),fromList [(1,&quot;ab&quot;)])]
1 out of 1 tests failed (0.00s)
*** Exception: ExitFailure 1
</pre></div><div class="top"><p class="src"><a id="v:exampleBug" class="def">exampleBug</a> :: <a href="https://hackage.haskell.org/package/-/docs/Test-Tasty-Providers.html#t:TestTree" title="Test.Tasty.Providers">TestTree</a> <a href="src/Examples.Ltl.Simple.html#exampleBug" class="link">Source</a> <a href="#v:exampleBug" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.27.0</p></div></body></html>